#!/usr/bin/env Rscript
# ==============================================================================
# Please review the Numbat paper (https://doi.org/10.1038/s41587-022-01468-y) and official documentation (https://kharchenkolab.github.io/numbat/) first.
# Clonal Heterogeneity Analysis from Numbat CNV Data
# 
# This script calculates clonal heterogeneity metrics from phylogenetic
# mutation graphs generated by Numbat (copy number alteration analysis tool).

# Input: Numbat output directories (per sample)
# Output: Clonal heterogeneity metrics
# ==============================================================================

# Load required libraries
suppressPackageStartupMessages({
  library(numbat)
  library(igraph)
  library(ineq)
  library(dplyr)
  library(tidyr)
})

cat("Loaded required packages:\n")
cat("  - numbat version:", as.character(packageVersion("numbat")), "\n")
cat("  - igraph version:", as.character(packageVersion("igraph")), "\n")
cat("  - ineq version:", as.character(packageVersion("ineq")), "\n\n")

# ==============================================================================
# CONFIGURATION
# ==============================================================================

# Define file paths (UPDATE THESE FOR YOUR DATA)
# INPUT_DIR should contain subdirectories, one per sample, with NUMBAT output
# Expected structure:
#   INPUT_DIR/
#   ├── Sample_01/  (Numbat output directory)
#   ├── Sample_02/
#   └── Sample_03/
INPUT_DIR <- "/path/to/numbat_output"
OUTPUT_DIR <- "/path/to/output"

# Create output directory
dir.create(OUTPUT_DIR, recursive = TRUE, showWarnings = FALSE)

# Sample group mapping (UPDATE THIS FOR YOUR DATA)
# Maps sample IDs to experimental groups
SAMPLE_GROUPS <- list(
  Sample_01 = "Group_A",
  Sample_02 = "Group_B",
  Sample_03 = "Group_B",
  Sample_04 = "Group_C",
  Sample_05 = "Group_C",
  Sample_06 = "Group_C",
  Sample_07 = "Group_B",
  Sample_08 = "Group_C",
  Sample_09 = "Group_A",
  Sample_10 = "Group_B",
  Sample_11 = "Group_D",
  Sample_12 = "Group_C",
  Sample_13 = "Group_D",
  Sample_14 = "Group_D",
  Sample_15 = "Group_A",
  Sample_16 = "Group_D",
  Sample_17 = "Group_D",
  Sample_18 = "Group_D"
)

# ==============================================================================
# CORE FUNCTIONS
# ==============================================================================

#' Calculate phylogenetic tree depth
#' 
#' Computes the maximum distance from the root node to any leaf node
#' in a phylogenetic tree represented as a graph.
#' 
#' @param graph igraph object representing mutation phylogeny
#' @return Numeric value of maximum tree depth
#' @examples
#' tree_depth <- calculate_tree_depth(mutation_graph)
calculate_tree_depth <- function(graph) {
  if (!inherits(graph, "igraph")) {
    stop("Input must be an igraph object")
  }
  
  if (vcount(graph) == 0) {
    return(0)
  }
  
  # Identify root node (highest out-degree)
  root_node <- which.max(degree(graph, mode = "out"))
  
  # Calculate distances from root to all nodes
  distances_from_root <- distances(graph, v = root_node, mode = "out")
  
  # Return maximum distance (tree depth)
  max_depth <- max(distances_from_root[is.finite(distances_from_root)], na.rm = TRUE)
  
  if (is.infinite(max_depth)) {
    return(0)
  }
  
  return(max_depth)
}

#' Count unique subclones
#' 
#' Determines the number of distinct clonal subpopulations based on
#' clone annotations in the mutation graph.
#' 
#' @param graph igraph object with 'clone' vertex attribute
#' @return Integer count of unique clones
#' @examples
#' n_clones <- count_subclones(mutation_graph)
count_subclones <- function(graph) {
  if (!inherits(graph, "igraph")) {
    stop("Input must be an igraph object")
  }
  
  if (vcount(graph) == 0) {
    return(0)
  }
  
  # Extract clone labels from vertices
  clone_labels <- V(graph)$clone
  
  if (is.null(clone_labels)) {
    warning("No 'clone' attribute found in graph. Using node IDs.")
    clone_labels <- V(graph)$name
  }
  
  # Count unique clones
  n_unique <- length(unique(clone_labels[!is.na(clone_labels)]))
  
  return(n_unique)
}

#' Calculate Gini coefficient
#' 
#' Computes the Gini coefficient of node degree distribution as a measure
#' of branching inequality in the phylogenetic tree.
#' 
#' @param graph igraph object
#' @return Numeric Gini coefficient (0 = perfect equality, 1 = perfect inequality)
#' @examples
#' gini_value <- calculate_gini(mutation_graph)
calculate_gini <- function(graph) {
  if (!inherits(graph, "igraph")) {
    stop("Input must be an igraph object")
  }
  
  if (vcount(graph) == 0) {
    return(0)
  }
  
  # Get degree distribution
  node_degrees <- degree(graph, mode = "all")
  
  if (length(node_degrees) < 2) {
    return(0)
  }
  
  # Calculate Gini coefficient
  gini_value <- ineq(node_degrees, type = "Gini")
  
  return(gini_value)
}

#' Min-max normalization
#' 
#' Scales values to 0-1 range using min-max normalization.
#' 
#' @param x Numeric vector
#' @return Normalized vector with values in [0, 1]
normalize_minmax <- function(x) {
  x_range <- max(x, na.rm = TRUE) - min(x, na.rm = TRUE)
  
  if (x_range == 0 || is.na(x_range)) {
    return(rep(0, length(x)))
  }
  
  (x - min(x, na.rm = TRUE)) / x_range
}

#' Calculate composite heterogeneity score
#' 
#' Combines normalized tree depth, subclone count, and Gini coefficient
#' into a single heterogeneity metric.
#' 
#' @param tree_depth_norm Normalized tree depth (0-1)
#' @param subclone_norm Normalized subclone count (0-1)
#' @param gini_coeff Gini coefficient (0-1)
#' @return Composite heterogeneity score (0-1)
calculate_heterogeneity_score <- function(tree_depth_norm, subclone_norm, gini_coeff) {
  tree_depth_norm * subclone_norm * gini_coeff
}

# ==============================================================================
# DATA LOADING FUNCTIONS
# ==============================================================================

#' Load mutation graph from Numbat output directory
#' 
#' Loads Numbat results and extracts the phylogenetic mutation graph.
#' Numbat output directory should contain standard Numbat output files.
#' 
#' @param sample_dir Path to Numbat output directory for a single sample
#' @return igraph object representing the mutation phylogeny, or NULL if loading fails
#' @examples
#' graph <- load_numbat_graph("/path/to/numbat_output/Sample_01")
load_numbat_graph <- function(sample_dir) {
  
  if (!dir.exists(sample_dir)) {
    warning(sprintf("Directory does not exist: %s", sample_dir))
    return(NULL)
  }
  
  tryCatch({
    # Load Numbat object from output directory
    numbat_obj <- Numbat$new(out_dir = sample_dir)
    
    # Extract mutation graph
    mut_graph <- numbat_obj$mut_graph
    
    if (is.null(mut_graph)) {
      warning(sprintf("No mutation graph found in: %s", sample_dir))
      return(NULL)
    }
    
    if (!inherits(mut_graph, "igraph")) {
      warning(sprintf("Invalid graph object in: %s", sample_dir))
      return(NULL)
    }
    
    return(mut_graph)
    
  }, error = function(e) {
    warning(sprintf("Failed to load NUMBAT data from %s: %s", sample_dir, e$message))
    return(NULL)
  })
}

# ==============================================================================
# MAIN ANALYSIS WORKFLOW
# ==============================================================================

#' Run clonal heterogeneity analysis on Numbat output
#' 
#' Processes Numbat output directories to calculate clonal heterogeneity metrics.
#' 
#' @param input_dir Directory containing Numbat output subdirectories
#' @param sample_groups Named list mapping sample IDs to groups
#' @return Data frame with heterogeneity metrics per sample
#' @examples
#' results <- run_heterogeneity_analysis(
#'   input_dir = "/path/to/numbat_output",
#'   sample_groups = list(Sample_01 = "Group_A", Sample_02 = "Group_B")
#' )
run_heterogeneity_analysis <- function(input_dir, sample_groups) {
  
  cat("Starting clonal heterogeneity analysis...\n")
  cat("Input directory:", input_dir, "\n")
  
  # Get Numbat output directories (one per sample)
  sample_paths <- list.dirs(input_dir, full.names = TRUE, recursive = FALSE)
  sample_ids <- basename(sample_paths)
  
  cat("Found", length(sample_ids), "samples\n\n")
  
  # Initialize results storage
  results <- data.frame(
    sample_id = character(),
    tree_depth = numeric(),
    subclone_count = numeric(),
    gini_coefficient = numeric(),
    stringsAsFactors = FALSE
  )
  
  # Process each sample
  for (i in seq_along(sample_ids)) {
    sample_id <- sample_ids[i]
    sample_path <- sample_paths[i]
    
    cat(sprintf("[%d/%d] Processing: %s\n", i, length(sample_ids), sample_id))
    
    tryCatch({
      # Load mutation graph from Numbat output
      mut_graph <- load_numbat_graph(sample_path)
      
      if (is.null(mut_graph)) {
        cat("  ✗ Failed to load graph\n")
        next
      }
      
      # Calculate metrics
      tree_depth <- calculate_tree_depth(mut_graph)
      n_subclones <- count_subclones(mut_graph)
      gini_coeff <- calculate_gini(mut_graph)
      
      # Store results
      results <- rbind(results, data.frame(
        sample_id = sample_id,
        tree_depth = tree_depth,
        subclone_count = n_subclones,
        gini_coefficient = gini_coeff,
        stringsAsFactors = FALSE
      ))
      
      cat(sprintf("  ✓ Depth: %.2f | Clones: %d | Gini: %.4f\n", 
                  tree_depth, n_subclones, gini_coeff))
      
    }, error = function(e) {
      cat(sprintf("  ✗ Error: %s\n", e$message))
    })
  }
  
  # Calculate composite scores
  cat("\nCalculating composite heterogeneity scores...\n")
  
  results <- results %>%
    mutate(
      tree_depth_norm = normalize_minmax(tree_depth),
      subclone_count_norm = normalize_minmax(subclone_count),
      heterogeneity_score = calculate_heterogeneity_score(
        tree_depth_norm,
        subclone_count_norm,
        gini_coefficient
      ),
      group = unlist(sample_groups[sample_id])
    )
  
  return(results)
}

# ==============================================================================
# EXAMPLE USAGE
# ==============================================================================

# results <- run_heterogeneity_analysis(
#   input_dir = INPUT_DIR,
#   sample_groups = SAMPLE_GROUPS
# )
# 
# # Save results
# write.csv(results, file.path(OUTPUT_DIR, "heterogeneity_metrics.csv"), row.names = FALSE)
# cat("\nAnalysis complete! Results saved to:", OUTPUT_DIR, "\n")
